# Implicit Indent Control

`CodegenTextWriter` magically controls the indentation of any object embedded inside interpolated strings.  

All you have to do is add the right amount of whitespace before the interpolated object - that's intuitive, friendly, and easy to read. 

Before any interpolated object is rendered the writer will capture the current indentation (capture how many spaces or tabs or any other character were written before the interpolated object), and if the interpolated object renders into multiple lines then all subsequent lines will get the same indentation as the first line.

In other words, the indentation set by the outer block is automatically captured and preserved.

T4, other templating engines and regular TextWriters lack any indent control: you have to **control indent on your own**  - each nested block needs to know how much padding (how many indent spaces or tabs) should be added so that the child block gets correctly aligned with the parent block.


## C# Example (for any curly-braces languages like C or Java)

```cs
class MyTemplate
{
    string myNamespace = "CodegenCS.Sample";
    string className = "MyAutogeneratedClass";
    string methodName = "HelloCodeGenerationWorld";

    FormattableString Main() => $$$"""
        namespace {{{myNamespace}}}
        {
            {{{ myClass }}}
        }
        """;

    FormattableString myClass() => $$$"""
        public class {{{className}}}()
        {
            {{{ myMethod }}}
        }
        """;

    FormattableString myMethod() => $$$"""
        public void {{{methodName}}}()
        {
            Console.WriteLine("Hello World");
        }
        """;

  // this example uses a "markup" approach (most methods are just returning text blocks)
  // but it would work similarly if you were manually calling CodegenTextWriter Write() or WriteLine()
}
```
It's important to note that all strings above are using Raw String Literals, which mean that the left padding of all blocks above will be left-trimmed. But yet `CodegenTextWriter` will automatically indent the embedded delegates: since `myClass` starts after 4 spaces then all its output will be indented by 4 spaces, and since `myMethod` starts after 8 spaces then all its output will be indented by 8 spaces.

The final output gets the indentation that you would expect:

```cs
namespace CodegenCS.Sample 
{
    public class MyAutogeneratedClass()
    {
        public void HelloCodeGenerationWorld()
        {
            Console.WriteLine("Hello World");
        }
    }
}
```

**If you were using a regular C# TextWriter** the first line of each inner block would be padded according to the outer block (it would "start after 4 spaces") but all subsequent lines would "go back to column 0", and this is what you would get:

```cs
namespace CodegenCS.Sample
{
    public class MyAutogeneratedClass()
{
    public void HelloCodeGenerationWorld()
{
    Console.WriteLine("Hello World");
}
}
}
```

Most other templating engines suffer from the same problem - an indented "partial" does not indent the whole output of the partial. So usually getting whitespace correct requires a lot of trial-and-error, and usually what you get is ugly and counterintuitive (mixed indentation).


## How it Works Internally

If you're curious about how it works, let's reveal the magic - this is how Implicit Indent Control works internally:
- The variable `myClass` is interpolated in the parent block and it's padded by 4 spaces (when compared to the parent block)
- The variable `myMethod` is interpolated in the parent block and it's padded by 4 spaces (when compared to the parent block)
- For each interpolated object CodegenTextWriter will create a **child scope**, and it will **automatically capture** the whitespace before the object.  
  In our example the whitespace was 4 spaces, but [it could be tabs](https://www.youtube.com/watch?v=SsoOG6ZeyUI), or any number of spaces/tabs - it's just captured as is.
- CodegenTextWriter will "intercept" whatever is written under a given child scope (even for multiple nested scope levels), and will ensure that subsequent lines (under that scope) will also padded by the same whitespace as the first line.  
  In other words, whenever the interpolated expression spans into multiple lines (text block) all those lines will be indented correctly (writer **preserves the indentation** of the whole block).
- One way of visualizing this is as if inner blocks are "pasted like a rectangle" ("preserving cursor position"), what some text editors would call "column mode".  
- Any number of levels work. `myMethod` lines will all be padded by 8 spaces (4 defined in the parent `myClass`, and 4 defined in the grandparent `myNamespace` block).

To sum, CodegenTextWriter will **preserve indent / keep cursor position** for any objects that are embedded in interpolated strings (even for complex objects like Actions/Funcs delegates, explained later in this document).


Implicitly controlling indentation using string interpolation is very elegant, works like magic and it's the preferred method. But if for any reason you think you need more control you might prefer to use [Explicit Indent Control](https://github.com/CodegenCS/CodegenCS/tree/master/src/Core/CodegenCS/Deprecated.md#ExplicitIndent) (e.g. manually calling `IncreaseIndent()`, `DecreaseIndent()`, etc.)

## Non-whitespace indent

By default even non-whitespace characters that occur before an interpolated object will be preserved (repeated in the subsequent lines), which is also friendly/intuitive:

```cs
class MyTemplate
{
  string[] groceries = new string[] { "Milk", "Eggs", "Diet Coke" };

  FormattableString Main() => $$"""
    I have to buy:
      - {{ groceries }}
    """;
}
```

Output:
```
I have to buy:
  - Milk
  - Eggs
  - Diet Coke
```

Or with comment-slashes:
```cs
class MyTemplate
{
  string entityDescription = """
    My class has a very very very
    very long description
    that spans across multiple lines
    """;

  FormattableString Main() => $$"""
    /// <summary>
    /// {{ entityDescription }}
    /// </summary>
    public class MyClass
    {
        // etc
    }
    """;
}
```

Output:
```cs
/// <summary>
/// My class has a very very very
/// very long description
/// that spans across multiple lines
/// </summary>
public class MyClass
{
    // etc
}
```


## Python Example (for Indentation-Based Languages)

Implicit indent control works for **any output that needs indenting (not only for curly-braces languages)**.  
Python is a good example (uses indenting but no curly-braces):

```cs
class MyTemplate
{
    string myNamespace = "CodegenCS.Sample";
    string className = "MyAutogeneratedClass";
    string methodName = "HelloCodeGenerationWorld";

    FormattableString Main() => $$"""
    from datetime import date

    # If today is Monday
    if date.today().weekday() == 0:
        {{ HappyMonday }}
    """;

    FormattableString happyMonday() => $$"""
        print("Hello!")
        print("It's great to see you again")
        print("Happy Monday!")
        """;
}
```

Thanks to our Magic TextWriter you get this:

```python
from datetime import date

# If today is Monday
if date.today().weekday() == 0:
    print("Hello!")
    print("It's great to see you again")
    print("Happy Monday!")
```

... instead of this (which you would get if using a standard `StringBuilder` or `TextWriter`):

```python
from datetime import date

# If today is Monday
if date.today().weekday() == 0:
    print("Hello!")
print("It's great to see you again")
print("Happy Monday!")
```


<br/><hr>

# No Mixed Indentation

T4 and other templating engines suffer from **Mixed Indentation** problem, where control logic and text blocks have conflicting indentation, making code harder to read.

CodegenCS does not have this problem (so our templates are **cleaner and easier to read**) for two reasons:

- Our templates are compiled using C# 11 so they support the powerful [C# 11 Raw String Literals](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-11#raw-string-literals) that allows multiline-blocks to be aligned (padded) wherever they look better  .
  It works even if your project is using C# 10 or older (templates compilation does not depend on your project)
- `CodegenTextWriter` has implicit indent control (explained earlier) which mean that nested blocks do NOT need to know about parent block indentation

This means that templates can be broken down into smaller pieces and still have maintenable and no-nonsense indentation.
